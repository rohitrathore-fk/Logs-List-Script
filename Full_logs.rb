def func_error(obj,string,message={}):
    print(string)
end

def func_debug(obj,string,message={}):
    print(string)
end  

def func_info(obj,string,message={}):
    print(string)
end

def func_warn(obj,string,message={}):
    print(string)
end


    

func_error(self, "Error converting time_stamp", error: e.message, backtrace: e.backtrace[0..5].join("\n"))
func_error(self, "Error while fetching customers for load #{load[:id]} for #{message_type}", error: e.message)
func_info(self, "Message SIBLING_LOADS_GROUPING queued in worker queue: #{sibling_group_messages}")
func_error(self, "Error queuing sibling loads grouping message #{sibling_group_messages}", error: e.message)
func_warn(self, "Company not found: #{company}", error: e.message)
func_error(self, "Error occurred while fetching sibling configuration from CS")
func_error(self, "Unable to fetch address #{address_ids} from geo service", error: e.message)
func_error(self, "[show_weights_and_rates?] Error while fetching relationship between shipper and carrier", e.message)
func_info(self, "Message #{message_type} queued in worker queue: #{message_id}")
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_error(self, "Partial error occurred while updating shared_with in #{table_name}")
func_error(self, "Trackings_ES_SYNC_FAILED:#{item['status']} ID:#{item['_id']}, #{item['result']}, #{item['error']}")
func_error(self, "Error in uploading Trackings data to ES", error: e.message)
func_info(self, "#{messages.size} messages queued in worker queue for CONSIGNMENT_GROUPING")
func_error(self, "Error queueing messages #{messages} to worker queue", error: e.message)
func_debug(self, "Sending message to KAFKA", topic: topic, messages: params, options: options)
func_debug(self, "Pushed message to KAFKA")
func_error(self, "Error Sending message to Kafka")
func_debug(self, "Sending message to KAFKA", topic: topic, messages: params, options: options)
func_debug(self, "Pushed message to KAFKA")
func_error(self, "Error Sending message to Kafka")
func_error(self, "Error queueing messages #{messages} to worker queue", error: e.message)
func_debug(self, "Eurl Template Id for #{company_id}:: #{tracking_mode}:: #{tracking_type} is #{template_id}")
func_error(self, "Error calling eurl service for template id for #{company_id}", error: e.message)
func_debug(self, "Current user company #{company_id}")
func_warn(self, "Error while calling ocean service client for load id #{tracking_id}", error: e.message)
func_debug(self, "Published tracking event #{params[:message]}")
func_warn(self, "Could not publish event #{params[:message]['EventType']}", error: e.message)
func_info(self,"Received new #{params[:documentType]} for load #{stop[:tracking_id]} for stop #{stop[:stop_id]}, deleted old files")
func_debug(self,
      "Sending Order status #{order_tracking_status} to status_change_to_po_pipeline for orders: #{orders}")
func_debug(self,
                                  "Sending message to KAFKA For Po Load Mapping tracking_ids: #{tracking_ids}", topic: topic, messages: messages)
func_debug(self, 'Pushed message to KAFKA')
func_error(self, 'Error Sending message to Kafka For Po')
func_debug(self, "sent_load_status_change_to_po_pipeline #{message['trackingId']}")
func_error(self, 'Failed to send kafka message to load status change po pipeline',
                                  error: e.message)
func_error(self, "Failed to retrieve relationship information for company_id: #{company_id} target_company_id: #{target_company_id}", error: e.message)
func_error(self, "Failed to retrieve relationship information for tpl_id: #{company_id} shipper_id: #{shipper_id}", error: e.message)
func_error(self, "Failed to retrieve company information for company_id: #{company_id}", error: e.message)
func_info(self, "picking up non_3pl_relationship for #{relationship.try(:[], 'company').try(:[], 'name') } AND #{ relationship.try(:[], 'targetCompany').try(:[], 'name') }")
func_debug(self, "V2 messages #{messages}")
func_info(self, "Skipping #{message_types} V2 messages from queuing to SQS")
func_info(self, "#{message_types} messages queued in worker queue: #{message_id}")
func_error(self, "Error queueing #{message_types} messages to worker queue", error: e.message)
func_warn(self, "Api call to global address service failed #{e}")
func_debug(self, "Recieved Line Item : #{pallet_part}")
func_debug(self, "SHARE_LOAD_LEVEL_UPDATES_WITH_LINK_LOADS message Queued sucessfully #{message}")
func_error(self, "Error ocuured while sharing load level updates with link loads #{ex.message}")
func_debug(self, "SHARE_STOP_LEVEL_UPDATES_WITH_LINK_LOADS message Queued sucessfully #{message}")
func_error(self, "Error ocuured while sharing stop level updates with link loads" + ex.message)
func_error(self, "#{error_message}", error: e.message)
func_debug(self, "last_departure_or_arrival_time #{last_departure_or_arrival_time}, timestamp #{timestamp}")
func_debug(self, "Autocomplete query: #{query_params}")
func_info(self, "Got ES results in #{Time.now - @start_time} secs")
func_debug(self, "es query: #{query_params}")
func_error(self, "Error queueing load_ids for Tags Hierarchy ", error: e.message)
func_error(self, "Error Occurred while fetching Child Companies. #{e}")
func_error(self, "Failed to store kafka message", error: e.message)
func_error(self, "Unable to get incentive load information", error: e.message)
func_error(self, "Failed to store kafka message", error: e.message)
func_info(self, "Deleted the tags #{tags_to_delete} and the files associated with stop IDs #{stop_ids} on tracking ID #{self.id} since carrier got updated from #{self.carrier_id_was} to #{self.carrier_id}")
func_info(self, "Message 'CALCULATE_MUST_PICKUP_BY_TIME' queued in worker queue: #{message_id}")
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_debug(self, "#{message_type} message queued in worker queue: #{message_id} for TrackingId: #{self.id}")
func_error(self, "Error queueing message #{messages} to worker queue", error: e.message)
func_debug(self, "Message queued in worker queue: #{message_id}")
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_error(self, "Failed to send message to air worker", error: e.message)
func_error(self, "Failed to store kafka message", error: e.message)
func_error(self, "Failed to store kafka message", error: e.message)
func_warn(self, "Error in publishing data to SQS", error: e.message)
func_debug(self, "ES_LOADS_TO_SYNC message queued for load #{self.id}")
func_error(self, "Error queueing loads to #{queue_name}", error: e.message)
func_info(self, "Message '#{message['MessageType']}' queued in worker queue: #{message}")
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_warn(self, "Error While resloving Timezone ShortName & Timezone Offset for #{message}", error: e.message)
func_debug(self, "Message queued in worker queue: #{message_id}")
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_info(self, "Changing status to tracking_info_assigned")
func_debug(self, "PERFORM_ETA_STATUS_EVALUATION message queued in worker queue")
func_info(self, "Error enqueuing PERFORM_ETA_STATUS_EVALUATION message", error: e.message)
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_error(self, "Failed to retrieve relationship information for shipper: #{shipper_id} carrier: #{carrier_id}", error: e.message)
func_error(self, "Failed to retrieve company object for carrier: #{carrier_id}", error: e.message)
func_error(self, "Failed to retrieve company modules for Order Visibility License check : #{self.shipper_id}", error: e.message)
func_debug(self, "ENQUEUE_LOAD_INFO_TO_KAFKA_FOR_SFA message queued in worker queue: #{message_id} for TrackingId: #{self.id}")
func_info(self, "Error enqueuing ENQUEUE_LOAD_INFO_TO_KAFKA_FOR_SFA message", error: e.message)
func_info(self, "no records to process")
func_warn(self, "no updates to process")
func_error(self, "Error queueing loads to #{queue_name} from Attributes model for load: #{self.parent_id}", error: e.message)
func_error(self, "Error queueing loads to #{queue_name} for load: #{self.tracking_id}", error: e.message)
func_info(self, "Error enqueuing PERFORM_TRACKING_CALCULATIONS message", error: e.message)
func_error(self, "Could not generate late reason code notification.", error: e.message)
func_error(self, "Error queueing message #{message} to worker queue", error: ex.message)
func_error(self, "Error transforming TRUCK_NOT_MOVING", error: e.message, backtrace: e.backtrace)
func_error(self, "Error queueing message #{message} to worker queue", error: ex.message)
func_error(self, "Error queueing message #{message} to worker queue", error: ex.message)
func_error(self, "Error transforming TEMPERATURE_OUTSIDE_THRESHOLD", error: e.message, backtrace: e.backtrace)
func_debug(self, "PostTemperatureUpdate: Sending message to SQS #{message}")
func_error(self, "Error queueing message #{message} to worker queue", error: ex.message)
func_error(self, "#{message['ErrorMessage'].to_s}. #{debug_message}", error: e.message)
func_error(self, "Could not send #{message['Message']['MessageType'].to_s} message", error: e.message)
func_debug(self, "CALCULATE_DELIVERY_APPOINTMENT_TIME message queued in worker queue: #{message_id} TrackingId: #{self.tracking_id} and StopId: #{self.id}")
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_debug(self, "STOP_ADDRESS_UPDATED message queued in worker queue: #{message_id}")
func_error(self, "Error queueing message #{complete_message} to worker queue", error: e.message)
func_debug(self, "Stop Want time Rescheduled update message queued in worker queue: #{message_id}")
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_debug(self, "INLAND_DELIVERY_DISTANCE_UPDATED message queued in worker queue")
func_error(self, "Error queuing INLAND_DELIVERY_DISTANCE_UPDATED message to worker queue", error: e.message)
func_debug(self, "AUTO_CALCULATE_LTL_PARCEL_DELIVERY_APPOINTMENT_TIME message queued in worker queue: #{message_id}")
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_error(self, "Unable to get mindistance for check_call #{check_call_time} error #{e}")
func_debug(self, "Sending message to KAFKA For PO on stop eta/status update", topic: topic, message: message)
func_debug(self, "Sending message to KAFKA for courier stop eta", topic: topic, message: message)
func_debug(self, "Update address statistics message queued in worker queue for address ids: #{old_address_id.to_s}, #{new_address_id.to_s}")
func_error(self, "Error queueing Update address statistics message for address ids: #{old_address_id.to_s}, #{new_address_id.to_s} to worker queue", error: e.message)
func_error(self, "Failed to store kafka message", error: e.message)
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_error(self, "Error queueing STOP_DEPARTURE_LTL message for load #{self.tracking_id} for stop #{self.stop_id}", error: e.message)
func_error(self, "Error queueing POPULATE_STOP_ETA_CONFIGURATION message", error: e.message)
func_debug(self, "Message queued in worker queue: #{message_id}")
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_error(self, "Error syncing carrier_eta for fourkitesx load: #{self.tracking_id}", error: e.message)
func_debug(self, "Sending message to Kafka - Stop ETA received for courier load", topic: topic, message: message)
func_info(self, "CARRIER_ETA_UPDATED callback sent for #{self.tracking_id}")
func_error(self, "Error queueing CARRIER_ETA_UPDATED message", error: e.message)
func_info(self, "FK_ETA_UPDATED message queued for #{self.tracking_id}")
func_error(self, "Error queueing FK_ETA_UPDATED message", error: e.message)
func_debug(self, "Send sqs message for file verification. document id: #{self.id}")
func_debug(self, "Adding  submission tags for file verification. document id: #{self.id}")
func_debug(self, "Send sqs message for document completion. document id: #{self.id}")
func_debug(self, "Adding  approval tags for file verification. document id: #{self.id},previous status: #{previous_status}")
func_error(self, "Exception in document attachement for file #{self.id}, stop_id: #{self.stop.id}", error: e.message)
func_error(self, "Exception in copying document attachment for file #{self.id}, stop_id: #{delivery_stop.id}", error: e.message)
func_error(self, "Error while pushing the callback message EDOCS_DETAILS", errors: e.message)
func_error(self, "Error queueing loads to #{queue_name} for load: #{tracking_stop.tracking_id}", error: e.message)
func_debug(self, "EDocs tag added when file created in load: load_id:#{tracking.id}") if update_edocs_tag(tracking)
func_debug(self, "EDocs event tag : #{self.notes}")
func_error(self, "KAFKA topic is missing for message: #{message}")
func_debug(self, "Sending message to KAFKA for tracking id: #{message['TrackingId']}", topic: topic, message: message)
func_debug(self, "Pushed message to KAFKA")
func_error(self, "Failed to push message to KAFKA", error: e.message)
func_debug(self, "calling batch sync SQS messages in after commit callback for queue #{queue_name}")
func_error(self, "Error when getting message for message type #{message_type}")
func_error(self, "Error when calling batch sync SQS message. #{e.message}")
func_error(self, "Error queueing loads to #{queue_name} for load: #{message['TrackingId']}", error: e.message)
func_debug(self, "#{message_type} message queued in worker queue: #{message_id}")
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_error(self, "Unable to get shipper data", error: e.message)
func_error(self, "Error while resolving timezone :: Timezone => #{timezone.to_s} :: time => #{time.to_s} :: error message => #{e.message}")
func_debug(self, "optional params with cache value in Presenter #{options['cached_tracking_updates']}")
func_debug(self, "Got fourkitesx data in #{Time.now - @start_time} secs")
func_debug(self, "Got split shipment trackings data in #{Time.now - @start_time} secs")
func_error(self, "Unable to get company data", error: e.message)
func_info(self, "Time taken to present load data for indexing: #{total_time_taken - total_time_taken_for_stops} and stop data for indexing: #{total_time_taken_for_stops}")
func_debug(self, "responses: #{responses}")
func_error(self, "Unable to global address for ocean stops #{params}", error: e.message)
func_info(self, "Insights ES Indexing Time taken #{time_hash}")
func_debug(self, "Will be creating a new update")
func_debug(self, "Will be just updating")
func_info(self, "No stop found with stop_id #{stop_params[:stopId]} for load #{tracking.id}")
func_info(self, "Eta source not available for storing eta")
func_info(self, "Invalid firstLocationPingAt, cannot be parsed. #{e.message}")
func_info(self, "Got new LTL load update with status #{status} and type #{value_type}")
func_info(self, "Eta source not available for storing eta")
func_info(self, "Invalid manuallyCompletedAt, cannot be parsed")
func_info(self, "Invalid estimatedArrivalTime, cannot be parsed")
func_info(self, "Invalid liveDwellStartAt, cannot be parsed")
func_info(self, "Invalid minDistanceCheckCallAt, cannot be parsed")
func_info(self, "Invalid arrivedAt, cannot be parsed")
func_info(self, "Invalid departedAt, cannot be parsed")
func_info(self, "Invalid #{timestamp_field}, cannot be parsed. #{e.message}")
func_info(self, "Invalid #{appointment_time_field}, cannot be parsed")
func_info(self, e.message)
func_error(self, "No carrier found , OperatingCarrierScac : #{operating_carrier_scac} , managingCarrier : #{load_params[:load][:carrier]}")
func_warn(self, "Carrier not found. #{e.message}")
func_info(self, "Cannot find product with externalId: #{external_id} in company: #{owner_id}")
func_warn(self, "Carrier not found. #{e.message}")
func_info(self, "stop_level_coordinates_sent_during_load_creation. #{additional_info}")
func_info(self, "Comments for file id #{file_id}", comments)
func_error(self, "Expection while calling ebol client for file #{file_id} ", error: e.message)
func_error(self, "Unable to send failed api params to firehose", error: e.message)
func_debug(self, "MG_RESPONSE_XML message queued in worker queue: #{message_id}")
func_error(self, "Error Sending message to SQS", error: e.message)
func_error(self, "Error Parsing Crux update", error: e.message)
func_info(self, "User #{copy_params[:copiedBy]} is not authorized to copy loads to the demo account #{copy_params[:targetShipper]}")
func_debug(self, "COPY_TRACKING_TO_DEMO_ACCOUNT message queued in worker queue: #{message_id}")
func_debug(self, "demo_company_permalink = #{demo_company_permalink}, copy_to_demo_company_settings = #{copy_to_demo_company_settings}")
func_debug(self, "Exception in can_user_copy_to_demo_company? check: #{e}")
func_error(self, "sourceLoadId/demoLoadId is empty")
func_error(self, "Couldn't prepare file: [#{file_name}]", error: e.message)
func_info(self, "uploading file #{file_name} from company: #{company_id} for provider: #{location_provider_id} to s3")
func_error(self, "Couldn't upload file: [#{file_name}] to s3", error: e.message)
func_error(self, "Error while pushing the LOAD_UPDATION message", errors: e.message)
func_info(self, "Loads Queue for Sync For Tags #{params[:tags]}")
func_error(self, "No geo_address to update stops.")
func_error(self, "Failed to set geo_address for stop because address is not found.")
func_error(self, "Failed to set geo_address for stop. #{e.message}")
func_warn(self, "Carrier is not specified")
func_warn(self, "Carrier is not in the network")
func_info(self, "Tracking record #{tracking.id} created successfully")
func_info(self, "#{notifications.size} messages queued in worker queue for TRACKING_CREATED")
func_error(self, "Error queueing messages #{notifications} to worker queue", error: e.message)
func_error(self, "failed to fetch carriers. #{e.message}")
func_error(self, "load: #{@tracking.id}, carrier: #{@tracking.carrier_id}", error: e.message)
func_error(self, "Error retrieving tracking ids from ES for Direct Assignment window", error: e.message)
func_info(self, "[HARD-LOAD-DELETION] Deleting #{params[:trackingIds]} loads from DB")
func_error(self, "Exception occurred while deleting #{params[:trackingIds]}", error: e.message)
func_error(self, "Error updating load #{@tracking.id} after validations", error: @tracking.errors.full_messages)
func_info(self, "Error getting milestone updates for #{tracking_id}")
func_warn(self, "#{@tracking.shipper_id} not exists")
func_warn(self, "Carrier is not specified")
func_error(self, 'Failed to get sibling loads info', error: e.message)
func_info(self, "get_loads_with_minimal_data started at #{@start_time}")
func_info(self, "Got ES results in #{Time.now - @start_time} secs")
func_info(self, "Got #{tracking_ids.length} records in #{(Time.now - @start_time) * 1000}ms")
func_error(self, 'Failed to search for load level data', error: e.message)
func_debug(self, "index started at #{@start_time}")
func_info(self, "#{I18n.translate('mabd.informational.success')} :: #{message}")
func_error(self, "#{I18n.translate('mabd.informational.error')} :: #{message}", error: e.message)
func_debug(self, "#{I18n.translate('recommendation.informational.export.success')} :: #{message}")
func_error(self, "#{I18n.translate('recommendation.informational.export.error')}", error: e.message)
func_info(self, "No.of Loads in edoc exceeds #{trackings.count}")
func_debug(self, "Carrier autocomplete query: #{query_params}")
func_info(self, "Got ES results in #{Time.now - @start_time} secs")
func_error(self, 'Failed to get results from ES', error: e.message)
func_info(self, "Returning #{@trackings.size} loads for the driver #{@phone || @driver_id}")
func_info(self, "ES query #{query_params}")
func_debug(self, "Message queued in worker queue: #{message_id}")
func_error(self, "Error queueing message #{message_id} to worker queue", error: e.message)
func_info(self, "Truck locations messages queued in worker queue")
func_error(self, "Error queueing messages to worker queue", error: ex.message)
func_error(self, "Error queueing messages to worker queue", error: e.message)
func_info(self, "Updating location information only. Location and stop status cannot be sent together")
func_info(self, "Location updates blacklisted for carrier #{carrier[:id]} and shipper #{location_params[:shipper]}")
func_debug(self, "Truck assignment message queued in #{queue_name} queue: #{message_id}")
func_error(self, "Error queueing message #{message} to #{queue_name} queue", error: e.message)
func_debug(self, "PROCESS_SUPER_RECORD message queued in SQS queue: #{messages.size}")
func_error(self, 'Failed to get consignment info', error: e.message)
func_debug(self, "Autocomplete query: #{query_params}")
func_info(self, "Got ES results in #{Time.now - @start_time} secs")
func_error(self, 'Failed to get results from ES', error: e.message)
func_error(self, 'Failed to update shared_with', error: e.message)
func_error(self, "Error updating load #{@tracking.id}", error: @tracking.errors.full_messages)
func_error(self, "Unauthorized access attempt for tracking record #{params[:id]}")
func_info(self, "Driver #{driver_phone} #{authorised ? "" : "not "}authorised for Shipper #{shipper_id} and Carrier #{carrier_id}")
func_warn(self, "date = #{date}, timezone_offset = #{timezone_offset}. Error at get_date_in_timezone #{ex}")
func_error(self, "Unable to get company data", error: e.message)
func_warn(self, "Carrier not found", error: e.message)
func_error(self, "Partial error in creation of Tracking::Stop::Address")
func_warn(self, "#{params[:action]} lock exists for load: #{params[:id]}")
func_error(self, "#{params[:action]} release_lock! error on #{params[:id]}", error: e.message)
func_error(self, "error creating tracking update for index #{index}, with errors : #{I18n.translate('updates.errors.duplicated_update_info')}")
func_error(self, "error creating tracking update for index #{index}, with errors : #{update.errors.full_messages}")
func_error(self,  "trackingUpdates does not have trackingId")
func_error(self, "error creating tracking update for index #{index}, with errors : #{update.errors.full_messages}")
func_error(self, "stop is not completed: #{@stop[:id]}, tracking id: #{@tracking[:id]}")
func_error(self, "stop competed before 7 days: #{@stop[:id]}, tracking id: #{@tracking[:id]}")
func_error(self, "pre-condition-failed: pickup-stop:#{@stop[:id]}, tracking-terminated:#{@tracking[:id]}")
func_info(self, "stop: #{@stop[:id]} is_origin_stop, tracking: #{@tracking[:id]}, undo pickup")
func_info(self, "stop: #{@stop[:id]}, tracking is terminated: #{@tracking[:id]}. restoring to tracking queue.")
func_error(self, "#{@stop[:id]}, tracking id: #{@tracking[:id]}, #{e.message}")
func_error(self, "stop not found, #{params[:id]}")
func_error(self, "Unauthorized access attempt for tracking record #{params[:id]}")
func_debug(self, "PERFORM_STATUS_UPDATE_ETA_CALCULATIONS message queued in worker queue: #{message_id}")
func_error(self, "PERFORM_STATUS_UPDATE_ETA_CALCULATIONS message queue failed for #{tracking.id}", error: e.message)
func_debug(self, "PROCESS_MANUAL_UPDATE message queued in worker queue: #{message_id}")
func_error(self, "PROCESS_MANUAL_UPDATE message queue failed for #{tracking.id}", error: e.message)
func_info(self, "Triggered KAFKA message for Po Eta Status", topic: topic, messages: message)
func_error(self, "Error Sending Eta message to Kafka For Po: tracking_id: #{stop.tracking_id}")
func_error(self, "Failed to create otm load for #{@company_id}", error: e.message)
func_debug(self, "uploading file #{request.uuid}.xml from shipper #{company_id} to s3")
func_error(self, "Unauthorized access attempt for tracking record #{params[:tracking_id]}")
func_error(self, "Unable to get shipper data", error: e.message)
func_error(self, "Unauthorized access attempt for tracking record #{params[:id]}")
func_error(self, "Unauthorized access attempt for tracking record #{params[:id]}")
func_debug(self, "PERFORM_TEMPERATURE_TRACKING_CALCULATIONS message queued in worker queue: #{message_id}")
func_error(self, "Error queueing PERFORM_TEMPERATURE_TRACKING_CALCULATIONS message for tracking id #{@tracking.id}")
func_error(self, "error in getting user for user id #{file.uploaded_by}", error: e.message)
func_error(self, "error in getting presigned URL", error: e.message)
func_error(self, "Unauthorized access attempt for tracking record #{params[:id]}")
func_error(self, "Error in creating update #{e.message}")
func_error(self, "Unauthorized access attempt for tracking record #{params[:id]}")
func_error(self, "Import Active record return success id and failed instances as blank #{results}")
func_info(self, "Documents is blank")
func_info(self, "Verification Params not valid")
func_info(self, "Error #{error_message}")
func_error(self, "Unauthorized access attempt for tracking record #{params[:tracking_id]}")
func_info(self, "Results is blank and documents length is #{documents.count}")
func_debug(self, response)
func_error(self, "Unauthorized access attempt for tracking record #{params[:tracking_id]}")
func_error(self, "error in getting presigned URL", error: e.message)
func_info(self, "File record #{file.id} for stop #{params[:stop_id]} created successfully")
func_error(self, "File is failed to create due to invalid data", errors: file.errors.full_messages)
func_debug(self, "File with id #{@file.id} submitted for verification")
func_info(self,
                                   "File record #{params[:fileId]} for stop #{params[:stop_id]} deleted successfully by #{current_user[:userId]}")
func_error(self,
                                    "File record #{params[:fileId]} for stop #{params[:stop_id]} does not exists")
func_error(self, "Unauthorized access attempt for tracking record #{params[:tracking_id]}")
func_error(self, "Load not created due to invalid or blank carrier")
func_info(self, "Updating load #{t.id}")
func_error(self, "Tracking record failed to create due to invalid data", errors: tracking.errors.full_messages)
func_info(self, "Tracking record #{tracking.id} created successfully")
func_error(self, "Tracking record failed to create due to invalid data", errors: tracking.errors.full_messages)
func_error(self, "Load not created due to invalid or blank carrier")
func_info(self, "Updating load #{t.id}")
func_error(self, "Tracking record failed to create due to invalid data", errors: tracking.errors.full_messages)
func_info(self, "Tracking record #{tracking.id} created successfully")
func_error(self, "Tracking record failed to create due to invalid data", errors: tracking.errors.full_messages)
func_error(self, "Error retrieving company details for carrier id #{@load_params[:CarrierId]} for load number #{create_params[:loadNumber]}", error: e.message)
func_debug(self, "Sending message DOCUMENT_VERIFICATION #{message}")
func_debug(self, "Redis key #{key}")
func_error(self, "Other errors")
func_info(self, "OTP valid")
func_info(self, "OTP not exists")
func_info(self, "OTP invalid")
func_warn(self, "NoResults Query #{e.message}")
func_error(self, 'Unable to push OCEAN_SERVICE_LOAD_SYNC message', error: e.message, backtrace: e.backtrace)
func_info(self, "Pushing edocs message - trigger: #{type}, source: #{get_edocs_table_name}, id: #{id}")
func_info(self, "Pushing edocs message - trigger: delete, source: #{get_edocs_table_name}, id: #{id}")
func_error(self, 'Unable to push AIR_SERVICE_LOAD_SYNC message', error: e.message, backtrace: e.backtrace)
func_debug(self, "EDocs tag not added when file verified in load: load_id:#{tracking.id}")
func_error(self, "Error while pushing the callback message EDOCS_DETAILS", errors: e.message)
func_info(self, "Message #{action} queued in #{worker_queue_name}: #{message}")
func_info(self, "Message #{STOP_DELETE} queued in #{worker_queue_name}: #{message}")
func_error(self, "Error queueing #{STOP_DELETE} to #{worker_queue_name}", error: e.message)
func_info(self, "Message #{TRACKING_DELETE} queued in #{worker_queue_name}: #{message}")
func_error(self, "Error queueing #{TRACKING_DELETE} to #{worker_queue_name}", error: e.message)
func_info(self, "Message CREATE_NON_FACILITY_CUSTOMERS queued in #{worker_queue_name}: #{message}")
func_debug(self, "Update address statistics messages queued for address #{address_details}")
func_error(self, "Error queueing address statistics messages for address #{address_details}", error: e.message)
func_debug(self, "Update address statistics messages for stop incompletion queued for address #{address_details}")
func_error(self, "Error queueing address statistics messages for stop incompletion for address #{address_details}", error: e.message)
func_debug(self, "Update address statistics messages queued for address #{address_details}")
func_error(self, "Error queueing address statistics messages for address #{address_details}", error: e.message)
func_error(self, "Unable to fetch addresses #{address_ids} from geo service", error: e.message)
func_debug(self, "Got addresses in #{Time.now - @start_time} secs")
func_error(self, "Unable to fetch addresses #{address_ids} from geo service", error: e.message)
func_debug(self, "Got addresses in #{Time.now - @start_time} secs")
func_warn(self, "address and location id map not present")
func_error(self, "Unable to map master address to stops #{stops}", error: e.message)
func_info(self, "Load #{load.id} Customer changed by carrier.")
func_debug(self, "es query: #{query_params}")
func_debug(self, "es results: #{es_results}")
func_warn(self, "NoResults Query #{e.message}")
func_debug(self, "es query: #{query_params}")
func_warn(self, "NoResults Query #{e.message}")
func_debug(self, "es query: #{query_params}")
func_debug(self, "es results: #{es_results}")
func_info(self, "Got ES results in #{Time.now - @start_time} secs")
func_warn(self, "NoResults Query #{e.message}")
func_warn(self, "NoResults Query #{e.message}")
func_debug(self, "#{message['CompanyId']} sent to worker queue")
func_info(self, "#{message['MessageType']} sent to worker queue")
func_error(self, "Error queueing messages #{message['MessageType']} to worker queue", error: e.message)
func_debug(self, "LTL_STOP_ETA_UPDATED message queued in worker queue: #{message_id}")
func_error(self, "Error queueing LTL_STOP_ETA_UPDATED message for tracking id: #{tracking.id} ", error: e.message)
func_debug(self, "Got customers in #{Time.now - @start_time} secs")
func_debug(self, "Got companies in #{Time.now - @start_time} secs")
func_error(self, "Error fetch companies with permalink : #{company_permalinks}", error: e.message)
func_info(self, "Ignoring mark the load : #{tracking.id} as delivered as it requested by a non special user and based on configuration for company : #{company[:id]}")
func_info(self, "[verify_lean_load_configuration] Exception occured for tacking_id: #{tracking.id}", error: e.message)
func_error(self, "error in PROCESS_SUPER_RECORD, #{e.message}")
func_info(self, "Timezone from location file config is: #{timezone} for company: #{company_id}")
func_info(self, "ES query for exports #{query_params}")
func_error(self, "Unable to parse load token", error: e.message)
func_info(self, "Mandatory params for sfa missing")
func_error(self, "Unauthorized access to tracking record #{params[:tracking_id]}")
func_error(self, "Error queueing ES_LOADS_TO_SYNC for load: #{tracking_id}", error: e.message)
func_info(self, "tracking: #{tracking.id}, tracking_stops.id: #{tracking_stop.id}, all delivery completed and all pickups not completed")
func_info(self, "tracking: #{tracking.id}, tracking_stops.id: #{tracking_stop.id}, 0 pickedup and more than 0 delivered")
func_debug(self, "es query: #{search_query}")
func_info(self, "Got ES results for DA in #{Time.now - start_time} secs")
func_info(self, "EurlInfo -> shipper :: #{tracking.shipper_id}, mode :: #{tracking.modes}, loadStatus :: #{tracking.status}, stopStatus :: #{stop.status}, arrivalTimeDiffInHours:: #{arrivalTimeDiffInHours}, departureTimeDiffInHours:: #{departureTimeDiffInHours}")
func_error(self, "Error occured while logging eurl metrics", error: e.message)
func_error(self, "Error occured in auto_complete_v1 for company #{query_params[:company_id]} and type #{query_params[:type]}", error: e.message)
func_error(self, "Error occured while fetching results from ES for DA auto suggest", error: e.message)
func_debug(self, "es query: #{search_query}")
func_error(self, "Unable to get company data", error: e.message)
func_info(self, "es results for chat bot load API: #{es_results}")
func_error(self, "Error queueing loads to #{queue_name} ids: #{ids}", error: e.message)
func_error(self, "Error queueing messages #{message}", error: e.message)
func_error(self, "Error queueing messages #{messages} to worker queue", error: e.message)
func_info(self, "Current user authentication #{encrypted_data} with access_code #{access_code}")
func_error(self, "error in getting user for user id #{@file.uploaded_by}", error: e.message)
func_error(self, "Error queueing message #{message} to worker queue", error: e.message)
func_warn(self, "NoResults Query #{e.message}")
func_debug(self, "PROCESS_MILESTONE_UPDATE messages queued in worker queue: #{message_id}")
func_error(self, "PROCESS_MILESTONE_UPDATE messages queue failed for #{messages}", error: e.message)
func_error(self, "Error updating timestamp in trackig update message", error: e.message)
func_error(self, "Error at temperature_tracking_enabled?: #{ex}")
func_warn(self, "Error in retrieving company details for shipper: #{shipper_id}", error: e.message)
func_error(self,"Operation '#{operation}' failed with error '#{error.inspect}'")
func_info(self, "#{observation.name}:#{observation.duration}:#{observation.cleaned_value}")
func_error(self, "Error while publishing result", error: e.message, backtrace: e.backtrace[0..5].join("\n"))
func_debug(self,"Enters send_batch_create_updates_to_tracking_updates_service: for tracking #{updates}")
func_info(self, "sending batch_create API of TUS for tracking id  : double write enabled request params #{tus_request_params}")
func_error(self, "error while sending batch_create_updates API of TUS for tracking id : with errors : #{e.message}")
func_debug(self,"Enters send_updates_to_tracking_updates_service: updates #{updates}")
func_info(self, "sending create_update API of TUS for tracking id : #{tracking.id} and updates #{updates}: double write enabled ")
func_error(self, "error while sending create_update API of TUS for tracking id : #{tracking.id}, with errors : #{e.message}")
func_debug(self,"Enters send_update_ltl_load_api_updates_to_tracking_updates_service: updates #{tracking_updates}")
func_info(self, "sending  update_ltl_load API of TUS for tracking id : #{tracking.id} and updates #{update_params}: double write enabled ")
func_error(self, "error while sending update_ltl_load API of TUS for tracking id : #{tracking.id}, with errors : #{e.message}")
func_debug(self,"Enters send_update_tracking_result_api_updates: tracking #{tracking} updates #{tracking_updates}")
func_info(self, "sending update_tracking_result API of TUS for tracking id : #{tracking.id} and updates #{tracking_update}: double write enabled ")
func_error(self, "error while sending update_tracking_result API of TUS for tracking id : #{tracking.id}, with errors : #{e.message}")
func_error(self, "error while sending #{options[:api]} API of TUS for tracking id : #{tracking_id}, with errors : #{e.message}")
func_error(self, "error while sending batch create updates API of TUS  with errors : #{e.message}")
func_error(self, "error while sending update_status of TUS for tracking id : #{tracking_id}, with errors : #{e.message}")
func_error(self, "Error while fetching updates", error: e.message, backtrace: e.backtrace[0..5].join("\n"))
func_error(self, "Error while comparing updates", error: e.message, backtrace: e.backtrace[0..5].join("\n"))
func_info(self, "Custom Field type mismatched #{custom_field[:type]} against #{matched_db_field}")
func_info(self, "Custom Field date format mismatched #{custom_field[:value]} against #{valid_form}")
func_warn(self, "NoResults Query #{e.message}")
func_warn(self, "NoResults Query #{e.message}")
func_info(self, "Exception in document attachement for pod #{self.id}, stop_id: #{self.stop.id}", error: e.message)
func_info(self, "Message #{message["MessageType"]} queued in worker queue when load updated: #{message_id}")
func_error(self, "Error queueing #{message["MessageType"]} to worker queue load updated", error: e.message)
func_warn(self, "NoResults Query #{e.message}")
func_warn(self, "NoResults Query #{e.message}")
func_warn(self, "NoResults Query #{e.message}")
func_warn(self, "NoResults Query #{e.message}")
func_warn(self, "NoResults Query #{e.message}")
func_warn(self, "NoResults Query #{e.message}")
func_warn(self, "NoResults Query #{e.message}")
func_warn(self, "NoResults Query #{e.message}")
func_warn(self, "NoResults Query #{e.message}")
func_warn(self, "NoResults Query #{e.message}")
func_debug(self, "Load Route aggreagtion Query  #{query}")
func_error(self, "Error occurred while applying NetworkVisibility mask setting #{e}")
func_error(self, "Error occurred while fetching NetworkVisibility mask Setting #{e}")
func_error(self, "Error occurred while applying NetworkVisibility mask setting #{e}")
func_error(self, "Unable to get company data", error: e.message)
func_warn(self, "NoResults Query #{e.message}")
func_warn(self, "NoResults Query #{e.message}")
func_warn(self, "date = #{date}, timezone_offset = #{timezone_offset}. Error at get_date_in_timezone #{ex}")
func_error(self, "customer not found")
func_error(self, "encryptionKey not found")
func_error(self, "customer not found")
func_error(self, "customer not found")
